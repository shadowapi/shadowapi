// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: message.sql

package query

import (
	"context"

	"github.com/gofrs/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createMessage = `-- name: CreateMessage :one
INSERT INTO message (
    uuid,
    source,
    type,
    chat_uuid,
    thread_uuid,
    sender,
    recipients,
    subject,
    body,
    body_parsed,
    reactions,
    attachments,
    forward_from,
    reply_to_message_uuid,
    forward_from_chat_uuid,
    forward_from_message_uuid,
    forward_meta,
    meta,
    created_at,
    updated_at
) VALUES (
             $1,
             $2,
             $3,
             $4,
             $5,
             $6,
             $7,
             $8,
             $9,
             $10,
             $11,
             $12,
             $13,
             $14,
             $15,
             $16,
             $17,
             $18,
             NOW(),
             NULL
         ) RETURNING uuid, source, type, chat_uuid, thread_uuid, sender, recipients, subject, body, body_parsed, reactions, attachments, forward_from, reply_to_message_uuid, forward_from_chat_uuid, forward_from_message_uuid, forward_meta, meta, created_at, updated_at
`

type CreateMessageParams struct {
	UUID                   uuid.UUID   `json:"uuid"`
	Source                 string      `json:"source"`
	Type                   string      `json:"type"`
	ChatUuid               *uuid.UUID  `json:"chat_uuid"`
	ThreadUuid             *uuid.UUID  `json:"thread_uuid"`
	Sender                 string      `json:"sender"`
	Recipients             []string    `json:"recipients"`
	Subject                pgtype.Text `json:"subject"`
	Body                   string      `json:"body"`
	BodyParsed             []byte      `json:"body_parsed"`
	Reactions              []byte      `json:"reactions"`
	Attachments            []byte      `json:"attachments"`
	ForwardFrom            pgtype.Text `json:"forward_from"`
	ReplyToMessageUuid     *uuid.UUID  `json:"reply_to_message_uuid"`
	ForwardFromChatUuid    *uuid.UUID  `json:"forward_from_chat_uuid"`
	ForwardFromMessageUuid *uuid.UUID  `json:"forward_from_message_uuid"`
	ForwardMeta            []byte      `json:"forward_meta"`
	Meta                   []byte      `json:"meta"`
}

func (q *Queries) CreateMessage(ctx context.Context, arg CreateMessageParams) (Message, error) {
	row := q.db.QueryRow(ctx, createMessage,
		arg.UUID,
		arg.Source,
		arg.Type,
		arg.ChatUuid,
		arg.ThreadUuid,
		arg.Sender,
		arg.Recipients,
		arg.Subject,
		arg.Body,
		arg.BodyParsed,
		arg.Reactions,
		arg.Attachments,
		arg.ForwardFrom,
		arg.ReplyToMessageUuid,
		arg.ForwardFromChatUuid,
		arg.ForwardFromMessageUuid,
		arg.ForwardMeta,
		arg.Meta,
	)
	var i Message
	err := row.Scan(
		&i.UUID,
		&i.Source,
		&i.Type,
		&i.ChatUuid,
		&i.ThreadUuid,
		&i.Sender,
		&i.Recipients,
		&i.Subject,
		&i.Body,
		&i.BodyParsed,
		&i.Reactions,
		&i.Attachments,
		&i.ForwardFrom,
		&i.ReplyToMessageUuid,
		&i.ForwardFromChatUuid,
		&i.ForwardFromMessageUuid,
		&i.ForwardMeta,
		&i.Meta,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteMessage = `-- name: DeleteMessage :exec
DELETE FROM message
WHERE uuid = $1
`

func (q *Queries) DeleteMessage(ctx context.Context, argUuid uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteMessage, argUuid)
	return err
}

const getMessage = `-- name: GetMessage :one
SELECT
    uuid, source, type, chat_uuid, thread_uuid, sender, recipients, subject, body, body_parsed, reactions, attachments, forward_from, reply_to_message_uuid, forward_from_chat_uuid, forward_from_message_uuid, forward_meta, meta, created_at, updated_at
FROM message
WHERE
    uuid = $1
LIMIT 1
`

func (q *Queries) GetMessage(ctx context.Context, argUuid uuid.UUID) (Message, error) {
	row := q.db.QueryRow(ctx, getMessage, argUuid)
	var i Message
	err := row.Scan(
		&i.UUID,
		&i.Source,
		&i.Type,
		&i.ChatUuid,
		&i.ThreadUuid,
		&i.Sender,
		&i.Recipients,
		&i.Subject,
		&i.Body,
		&i.BodyParsed,
		&i.Reactions,
		&i.Attachments,
		&i.ForwardFrom,
		&i.ReplyToMessageUuid,
		&i.ForwardFromChatUuid,
		&i.ForwardFromMessageUuid,
		&i.ForwardMeta,
		&i.Meta,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listMessages = `-- name: ListMessages :many
SELECT
    uuid, source, type, chat_uuid, thread_uuid, sender, recipients, subject, body, body_parsed, reactions, attachments, forward_from, reply_to_message_uuid, forward_from_chat_uuid, forward_from_message_uuid, forward_meta, meta, created_at, updated_at
FROM message
ORDER BY created_at DESC
LIMIT CASE WHEN $2::int = 0 THEN NULL ELSE $2::int END
    OFFSET $1::int
`

type ListMessagesParams struct {
	OffsetRecords int32 `json:"offset_records"`
	LimitRecords  int32 `json:"limit_records"`
}

func (q *Queries) ListMessages(ctx context.Context, arg ListMessagesParams) ([]Message, error) {
	rows, err := q.db.Query(ctx, listMessages, arg.OffsetRecords, arg.LimitRecords)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Message
	for rows.Next() {
		var i Message
		if err := rows.Scan(
			&i.UUID,
			&i.Source,
			&i.Type,
			&i.ChatUuid,
			&i.ThreadUuid,
			&i.Sender,
			&i.Recipients,
			&i.Subject,
			&i.Body,
			&i.BodyParsed,
			&i.Reactions,
			&i.Attachments,
			&i.ForwardFrom,
			&i.ReplyToMessageUuid,
			&i.ForwardFromChatUuid,
			&i.ForwardFromMessageUuid,
			&i.ForwardMeta,
			&i.Meta,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateMessage = `-- name: UpdateMessage :exec
UPDATE message
SET
    source                    = COALESCE($1, source),
    type                      = COALESCE($2, type),
    chat_uuid                 = COALESCE($3, chat_uuid),
    thread_uuid               = COALESCE($4, thread_uuid),
    sender                    = COALESCE($5, sender),
    recipients                = COALESCE($6, recipients),
    subject                   = COALESCE($7, subject),
    body                      = COALESCE($8, body),
    body_parsed               = COALESCE($9, body_parsed),
    reactions                 = COALESCE($10, reactions),
    attachments               = COALESCE($11, attachments),
    forward_from              = COALESCE($12, forward_from),
    reply_to_message_uuid     = COALESCE($13, reply_to_message_uuid),
    forward_from_chat_uuid    = COALESCE($14, forward_from_chat_uuid),
    forward_from_message_uuid = COALESCE($15, forward_from_message_uuid),
    forward_meta              = COALESCE($16, forward_meta),
    meta                      = COALESCE($17, meta),
    updated_at                = NOW()
WHERE uuid = $18
`

type UpdateMessageParams struct {
	Source                 string      `json:"source"`
	Type                   string      `json:"type"`
	ChatUuid               *uuid.UUID  `json:"chat_uuid"`
	ThreadUuid             *uuid.UUID  `json:"thread_uuid"`
	Sender                 string      `json:"sender"`
	Recipients             []string    `json:"recipients"`
	Subject                pgtype.Text `json:"subject"`
	Body                   string      `json:"body"`
	BodyParsed             []byte      `json:"body_parsed"`
	Reactions              []byte      `json:"reactions"`
	Attachments            []byte      `json:"attachments"`
	ForwardFrom            pgtype.Text `json:"forward_from"`
	ReplyToMessageUuid     *uuid.UUID  `json:"reply_to_message_uuid"`
	ForwardFromChatUuid    *uuid.UUID  `json:"forward_from_chat_uuid"`
	ForwardFromMessageUuid *uuid.UUID  `json:"forward_from_message_uuid"`
	ForwardMeta            []byte      `json:"forward_meta"`
	Meta                   []byte      `json:"meta"`
	UUID                   uuid.UUID   `json:"uuid"`
}

func (q *Queries) UpdateMessage(ctx context.Context, arg UpdateMessageParams) error {
	_, err := q.db.Exec(ctx, updateMessage,
		arg.Source,
		arg.Type,
		arg.ChatUuid,
		arg.ThreadUuid,
		arg.Sender,
		arg.Recipients,
		arg.Subject,
		arg.Body,
		arg.BodyParsed,
		arg.Reactions,
		arg.Attachments,
		arg.ForwardFrom,
		arg.ReplyToMessageUuid,
		arg.ForwardFromChatUuid,
		arg.ForwardFromMessageUuid,
		arg.ForwardMeta,
		arg.Meta,
		arg.UUID,
	)
	return err
}
