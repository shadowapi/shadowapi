// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: message.sql

package query

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createMessage = `-- name: CreateMessage :one
INSERT INTO message (
    uuid,
    source,
    type,
    chat_uuid,
    thread_uuid,
    sender,
    recipients,
    subject,
    body,
    body_parsed,
    reactions,
    attachments,
    forward_from,
    reply_to_message_uuid,
    forward_from_chat_uuid,
    forward_from_message_uuid,
    forward_meta,
    meta,
    created_at,
    updated_at
) VALUES (
             $1::uuid,
             NULLIF($2, '')::uuid,
             NULLIF($3, ''),
             NULLIF($4, '')::uuid,
             NULLIF($5, '')::uuid,
             $6,
             $7,
             $8,
             $9,
             $10,
             $11,
             $12,
             $13,
             NULLIF($14, '')::uuid,
             NULLIF($15, '')::uuid,
             NULLIF($16, '')::uuid,
             $17,
             $18,
             NOW(),
             NOW()
         ) RETURNING uuid, source, type, chat_uuid, thread_uuid, sender, recipients, subject, body, body_parsed, reactions, attachments, forward_from, reply_to_message_uuid, forward_from_chat_uuid, forward_from_message_uuid, forward_meta, meta, created_at, updated_at
`

type CreateMessageParams struct {
	UUID                   pgtype.UUID `json:"uuid"`
	Source                 interface{} `json:"source"`
	Type                   interface{} `json:"type"`
	ChatUuid               interface{} `json:"chat_uuid"`
	ThreadUuid             interface{} `json:"thread_uuid"`
	Sender                 string      `json:"sender"`
	Recipients             []string    `json:"recipients"`
	Subject                pgtype.Text `json:"subject"`
	Body                   string      `json:"body"`
	BodyParsed             []byte      `json:"body_parsed"`
	Reactions              []byte      `json:"reactions"`
	Attachments            []byte      `json:"attachments"`
	ForwardFrom            pgtype.Text `json:"forward_from"`
	ReplyToMessageUuid     interface{} `json:"reply_to_message_uuid"`
	ForwardFromChatUuid    interface{} `json:"forward_from_chat_uuid"`
	ForwardFromMessageUuid interface{} `json:"forward_from_message_uuid"`
	ForwardMeta            []byte      `json:"forward_meta"`
	Meta                   []byte      `json:"meta"`
}

func (q *Queries) CreateMessage(ctx context.Context, arg CreateMessageParams) (Message, error) {
	row := q.db.QueryRow(ctx, createMessage,
		arg.UUID,
		arg.Source,
		arg.Type,
		arg.ChatUuid,
		arg.ThreadUuid,
		arg.Sender,
		arg.Recipients,
		arg.Subject,
		arg.Body,
		arg.BodyParsed,
		arg.Reactions,
		arg.Attachments,
		arg.ForwardFrom,
		arg.ReplyToMessageUuid,
		arg.ForwardFromChatUuid,
		arg.ForwardFromMessageUuid,
		arg.ForwardMeta,
		arg.Meta,
	)
	var i Message
	err := row.Scan(
		&i.UUID,
		&i.Source,
		&i.Type,
		&i.ChatUuid,
		&i.ThreadUuid,
		&i.Sender,
		&i.Recipients,
		&i.Subject,
		&i.Body,
		&i.BodyParsed,
		&i.Reactions,
		&i.Attachments,
		&i.ForwardFrom,
		&i.ReplyToMessageUuid,
		&i.ForwardFromChatUuid,
		&i.ForwardFromMessageUuid,
		&i.ForwardMeta,
		&i.Meta,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteMessage = `-- name: DeleteMessage :exec
DELETE FROM message WHERE uuid = $1::uuid
`

func (q *Queries) DeleteMessage(ctx context.Context, uuid pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteMessage, uuid)
	return err
}

const getMessage = `-- name: GetMessage :one
SELECT
    uuid, source, type, chat_uuid, thread_uuid, sender, recipients, subject, body, body_parsed, reactions, attachments, forward_from, reply_to_message_uuid, forward_from_chat_uuid, forward_from_message_uuid, forward_meta, meta, created_at, updated_at
FROM message
WHERE uuid = $1::uuid
`

func (q *Queries) GetMessage(ctx context.Context, uuid pgtype.UUID) (Message, error) {
	row := q.db.QueryRow(ctx, getMessage, uuid)
	var i Message
	err := row.Scan(
		&i.UUID,
		&i.Source,
		&i.Type,
		&i.ChatUuid,
		&i.ThreadUuid,
		&i.Sender,
		&i.Recipients,
		&i.Subject,
		&i.Body,
		&i.BodyParsed,
		&i.Reactions,
		&i.Attachments,
		&i.ForwardFrom,
		&i.ReplyToMessageUuid,
		&i.ForwardFromChatUuid,
		&i.ForwardFromMessageUuid,
		&i.ForwardMeta,
		&i.Meta,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listMessages = `-- name: ListMessages :many
SELECT
    uuid, source, type, chat_uuid, thread_uuid, sender, recipients, subject, body, body_parsed, reactions, attachments, forward_from, reply_to_message_uuid, forward_from_chat_uuid, forward_from_message_uuid, forward_meta, meta, created_at, updated_at
FROM message
ORDER BY created_at DESC
LIMIT NULLIF($2::int, 0)
    OFFSET $1
`

type ListMessagesParams struct {
	Offset int32 `json:"offset"`
	Limit  int32 `json:"limit"`
}

func (q *Queries) ListMessages(ctx context.Context, arg ListMessagesParams) ([]Message, error) {
	rows, err := q.db.Query(ctx, listMessages, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Message
	for rows.Next() {
		var i Message
		if err := rows.Scan(
			&i.UUID,
			&i.Source,
			&i.Type,
			&i.ChatUuid,
			&i.ThreadUuid,
			&i.Sender,
			&i.Recipients,
			&i.Subject,
			&i.Body,
			&i.BodyParsed,
			&i.Reactions,
			&i.Attachments,
			&i.ForwardFrom,
			&i.ReplyToMessageUuid,
			&i.ForwardFromChatUuid,
			&i.ForwardFromMessageUuid,
			&i.ForwardMeta,
			&i.Meta,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateMessage = `-- name: UpdateMessage :exec
UPDATE message
SET
    source                    = NULLIF($1, '')::uuid,
    type                      = NULLIF($2, ''),
    chat_uuid                 = NULLIF($3, '')::uuid,
    thread_uuid               = NULLIF($4, '')::uuid,
    sender                    =  $5,
    recipients                = $6,
    subject                   = $7,
    body                      = $8,
    body_parsed               =  $9,
    reactions                 = $10,
    attachments               =  $11,
    forward_from              = $12,
    reply_to_message_uuid     = NULLIF($13, '')::uuid,
    forward_from_chat_uuid    = NULLIF($14, '')::uuid,
    forward_from_message_uuid = NULLIF($15, '')::uuid,
    forward_meta              = $16,
    meta                      = $17,
    updated_at = NOW()
WHERE uuid = $18::uuid
`

type UpdateMessageParams struct {
	Source                 interface{} `json:"source"`
	Type                   interface{} `json:"type"`
	ChatUuid               interface{} `json:"chat_uuid"`
	ThreadUuid             interface{} `json:"thread_uuid"`
	Sender                 string      `json:"sender"`
	Recipients             []string    `json:"recipients"`
	Subject                pgtype.Text `json:"subject"`
	Body                   string      `json:"body"`
	BodyParsed             []byte      `json:"body_parsed"`
	Reactions              []byte      `json:"reactions"`
	Attachments            []byte      `json:"attachments"`
	ForwardFrom            pgtype.Text `json:"forward_from"`
	ReplyToMessageUuid     interface{} `json:"reply_to_message_uuid"`
	ForwardFromChatUuid    interface{} `json:"forward_from_chat_uuid"`
	ForwardFromMessageUuid interface{} `json:"forward_from_message_uuid"`
	ForwardMeta            []byte      `json:"forward_meta"`
	Meta                   []byte      `json:"meta"`
	UUID                   pgtype.UUID `json:"uuid"`
}

func (q *Queries) UpdateMessage(ctx context.Context, arg UpdateMessageParams) error {
	_, err := q.db.Exec(ctx, updateMessage,
		arg.Source,
		arg.Type,
		arg.ChatUuid,
		arg.ThreadUuid,
		arg.Sender,
		arg.Recipients,
		arg.Subject,
		arg.Body,
		arg.BodyParsed,
		arg.Reactions,
		arg.Attachments,
		arg.ForwardFrom,
		arg.ReplyToMessageUuid,
		arg.ForwardFromChatUuid,
		arg.ForwardFromMessageUuid,
		arg.ForwardMeta,
		arg.Meta,
		arg.UUID,
	)
	return err
}
