// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: oauth2_state.sql

package query

import (
	"context"

	"github.com/gofrs/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createOauth2State = `-- name: CreateOauth2State :one
INSERT INTO oauth2_state (
    uuid,
    client_uuid,
    state,
    created_at,
    updated_at,
    expired_at
) VALUES (
             $1::uuid,
             $2::uuid,
             $3,
             NOW(),
             NOW(),
             $4
         ) RETURNING uuid, client_uuid, state, created_at, updated_at, expired_at
`

type CreateOauth2StateParams struct {
	UUID       pgtype.UUID        `json:"uuid"`
	ClientUuid pgtype.UUID        `json:"client_uuid"`
	State      []byte             `json:"state"`
	ExpiredAt  pgtype.Timestamptz `json:"expired_at"`
}

func (q *Queries) CreateOauth2State(ctx context.Context, arg CreateOauth2StateParams) (Oauth2State, error) {
	row := q.db.QueryRow(ctx, createOauth2State,
		arg.UUID,
		arg.ClientUuid,
		arg.State,
		arg.ExpiredAt,
	)
	var i Oauth2State
	err := row.Scan(
		&i.UUID,
		&i.ClientUuid,
		&i.State,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ExpiredAt,
	)
	return i, err
}

const deleteOauth2State = `-- name: DeleteOauth2State :exec
DELETE FROM oauth2_state
WHERE uuid = $1::uuid
`

func (q *Queries) DeleteOauth2State(ctx context.Context, argUuid pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteOauth2State, argUuid)
	return err
}

const getOauth2State = `-- name: GetOauth2State :one
SELECT
    oauth2_state.uuid, oauth2_state.client_uuid, oauth2_state.state, oauth2_state.created_at, oauth2_state.updated_at, oauth2_state.expired_at
FROM oauth2_state
WHERE uuid = $1::uuid
`

type GetOauth2StateRow struct {
	Oauth2State Oauth2State `json:"oauth2_state"`
}

func (q *Queries) GetOauth2State(ctx context.Context, argUuid pgtype.UUID) (GetOauth2StateRow, error) {
	row := q.db.QueryRow(ctx, getOauth2State, argUuid)
	var i GetOauth2StateRow
	err := row.Scan(
		&i.Oauth2State.UUID,
		&i.Oauth2State.ClientUuid,
		&i.Oauth2State.State,
		&i.Oauth2State.CreatedAt,
		&i.Oauth2State.UpdatedAt,
		&i.Oauth2State.ExpiredAt,
	)
	return i, err
}

const getOauth2States = `-- name: GetOauth2States :many
WITH filtered_oauth2_states AS (
    SELECT os.uuid, os.client_uuid, os.state, os.created_at, os.updated_at, os.expired_at
    FROM oauth2_state os
    WHERE
      (NULLIF($5, '') IS NULL OR os.client_uuid = $5::uuid)
)
SELECT
    uuid, client_uuid, state, created_at, updated_at, expired_at,
    (SELECT count(*) FROM filtered_oauth2_states) as total_count
FROM filtered_oauth2_states
ORDER BY
    CASE WHEN $1 = 'created_at' AND $2 = 'asc' THEN created_at END ASC,
    CASE WHEN $1 = 'created_at' AND $2 = 'desc' THEN created_at END DESC,
    CASE WHEN $1 = 'updated_at' AND $2 = 'asc' THEN updated_at END ASC,
    CASE WHEN $1 = 'updated_at' AND $2 = 'desc' THEN updated_at END DESC,
    created_at DESC
LIMIT NULLIF($4::int, 0)
    OFFSET $3::int
`

type GetOauth2StatesParams struct {
	OrderBy        interface{} `json:"order_by"`
	OrderDirection interface{} `json:"order_direction"`
	Offset         int32       `json:"offset"`
	Limit          int32       `json:"limit"`
	ClientUuid     interface{} `json:"client_uuid"`
}

type GetOauth2StatesRow struct {
	UUID       uuid.UUID          `json:"uuid"`
	ClientUuid *uuid.UUID         `json:"client_uuid"`
	State      []byte             `json:"state"`
	CreatedAt  pgtype.Timestamptz `json:"created_at"`
	UpdatedAt  pgtype.Timestamptz `json:"updated_at"`
	ExpiredAt  pgtype.Timestamptz `json:"expired_at"`
	TotalCount int64              `json:"total_count"`
}

func (q *Queries) GetOauth2States(ctx context.Context, arg GetOauth2StatesParams) ([]GetOauth2StatesRow, error) {
	rows, err := q.db.Query(ctx, getOauth2States,
		arg.OrderBy,
		arg.OrderDirection,
		arg.Offset,
		arg.Limit,
		arg.ClientUuid,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetOauth2StatesRow
	for rows.Next() {
		var i GetOauth2StatesRow
		if err := rows.Scan(
			&i.UUID,
			&i.ClientUuid,
			&i.State,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ExpiredAt,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOauth2States = `-- name: ListOauth2States :many
SELECT
    oauth2_state.uuid, oauth2_state.client_uuid, oauth2_state.state, oauth2_state.created_at, oauth2_state.updated_at, oauth2_state.expired_at
FROM oauth2_state
ORDER BY created_at DESC
LIMIT NULLIF($2::int, 0)
    OFFSET $1::int
`

type ListOauth2StatesParams struct {
	Offset int32 `json:"offset"`
	Limit  int32 `json:"limit"`
}

type ListOauth2StatesRow struct {
	Oauth2State Oauth2State `json:"oauth2_state"`
}

func (q *Queries) ListOauth2States(ctx context.Context, arg ListOauth2StatesParams) ([]ListOauth2StatesRow, error) {
	rows, err := q.db.Query(ctx, listOauth2States, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListOauth2StatesRow
	for rows.Next() {
		var i ListOauth2StatesRow
		if err := rows.Scan(
			&i.Oauth2State.UUID,
			&i.Oauth2State.ClientUuid,
			&i.Oauth2State.State,
			&i.Oauth2State.CreatedAt,
			&i.Oauth2State.UpdatedAt,
			&i.Oauth2State.ExpiredAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateOauth2State = `-- name: UpdateOauth2State :exec
UPDATE oauth2_state SET
                        state = $1,
                        updated_at = NOW(),
                        expired_at = $2
WHERE uuid = $3::uuid
`

type UpdateOauth2StateParams struct {
	State     []byte             `json:"state"`
	ExpiredAt pgtype.Timestamptz `json:"expired_at"`
	UUID      pgtype.UUID        `json:"uuid"`
}

func (q *Queries) UpdateOauth2State(ctx context.Context, arg UpdateOauth2StateParams) error {
	_, err := q.db.Exec(ctx, updateOauth2State, arg.State, arg.ExpiredAt, arg.UUID)
	return err
}
