// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: oauth2.sql

package query

import (
	"context"
	"time"

	"github.com/gofrs/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const addOauth2Token = `-- name: AddOauth2Token :exec
INSERT INTO oauth2_token (
  uuid, client_id, token
) VALUES (
  $1, $2, $3
)
`

type AddOauth2TokenParams struct {
	UUID     uuid.UUID `json:"uuid"`
	ClientID string    `json:"client_id"`
	Token    []byte    `json:"token"`
}

func (q *Queries) AddOauth2Token(ctx context.Context, arg AddOauth2TokenParams) error {
	_, err := q.db.Exec(ctx, addOauth2Token, arg.UUID, arg.ClientID, arg.Token)
	return err
}

const createOauth2Client = `-- name: CreateOauth2Client :one
INSERT INTO oauth2_client (
  id, provider, name, secret
) VALUES (
  $1, $2, $3, $4
) RETURNING id, name, provider, secret, created_at, updated_at
`

type CreateOauth2ClientParams struct {
	ID       string `json:"id"`
	Provider string `json:"provider"`
	Name     string `json:"name"`
	Secret   string `json:"secret"`
}

func (q *Queries) CreateOauth2Client(ctx context.Context, arg CreateOauth2ClientParams) (Oauth2Client, error) {
	row := q.db.QueryRow(ctx, createOauth2Client,
		arg.ID,
		arg.Provider,
		arg.Name,
		arg.Secret,
	)
	var i Oauth2Client
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Provider,
		&i.Secret,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createOauth2State = `-- name: CreateOauth2State :one
INSERT INTO oauth2_state (
  uuid, client_name, client_id, state, expired_at
) VALUES (
  $1, $2, $3, $4, NOW() + interval '1 hour'
) RETURNING uuid, client_name, client_id, state, created_at, updated_at, expired_at
`

type CreateOauth2StateParams struct {
	UUID       uuid.UUID `json:"uuid"`
	ClientName string    `json:"client_name"`
	ClientID   string    `json:"client_id"`
	State      []byte    `json:"state"`
}

func (q *Queries) CreateOauth2State(ctx context.Context, arg CreateOauth2StateParams) (Oauth2State, error) {
	row := q.db.QueryRow(ctx, createOauth2State,
		arg.UUID,
		arg.ClientName,
		arg.ClientID,
		arg.State,
	)
	var i Oauth2State
	err := row.Scan(
		&i.UUID,
		&i.ClientName,
		&i.ClientID,
		&i.State,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ExpiredAt,
	)
	return i, err
}

const createOauth2Subject = `-- name: CreateOauth2Subject :one
INSERT INTO oauth2_subject (
  uuid, user_uuid, client_id, client_name, expired_at
) VALUES (
  $1, $2, $3, $4, $5
) RETURNING uuid, user_uuid, client_name, client_id, token, created_at, updated_at, expired_at
`

type CreateOauth2SubjectParams struct {
	UUID       uuid.UUID          `json:"uuid"`
	UserUUID   *uuid.UUID         `json:"user_uuid"`
	ClientID   string             `json:"client_id"`
	ClientName string             `json:"client_name"`
	ExpiredAt  pgtype.Timestamptz `json:"expired_at"`
}

func (q *Queries) CreateOauth2Subject(ctx context.Context, arg CreateOauth2SubjectParams) (Oauth2Subject, error) {
	row := q.db.QueryRow(ctx, createOauth2Subject,
		arg.UUID,
		arg.UserUUID,
		arg.ClientID,
		arg.ClientName,
		arg.ExpiredAt,
	)
	var i Oauth2Subject
	err := row.Scan(
		&i.UUID,
		&i.UserUUID,
		&i.ClientName,
		&i.ClientID,
		&i.Token,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ExpiredAt,
	)
	return i, err
}

const deleteOauth2Client = `-- name: DeleteOauth2Client :exec
DELETE FROM oauth2_client
WHERE id = $1
`

func (q *Queries) DeleteOauth2Client(ctx context.Context, id string) error {
	_, err := q.db.Exec(ctx, deleteOauth2Client, id)
	return err
}

const deleteOauth2Token = `-- name: DeleteOauth2Token :exec
DELETE FROM oauth2_token
WHERE uuid = $1
`

func (q *Queries) DeleteOauth2Token(ctx context.Context, argUuid uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteOauth2Token, argUuid)
	return err
}

const deleteOauth2TokenByClientID = `-- name: DeleteOauth2TokenByClientID :exec
DELETE FROM oauth2_token
WHERE client_id = $1
`

func (q *Queries) DeleteOauth2TokenByClientID(ctx context.Context, clientID string) error {
	_, err := q.db.Exec(ctx, deleteOauth2TokenByClientID, clientID)
	return err
}

const getOauth2Client = `-- name: GetOauth2Client :one
SELECT
  id, name, provider, secret, created_at, updated_at
FROM oauth2_client
WHERE 
  id = $1
LIMIT 1
`

func (q *Queries) GetOauth2Client(ctx context.Context, id string) (Oauth2Client, error) {
	row := q.db.QueryRow(ctx, getOauth2Client, id)
	var i Oauth2Client
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Provider,
		&i.Secret,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getOauth2ClientTokens = `-- name: GetOauth2ClientTokens :many
SELECT
  ot.uuid, ot.client_id, ot.token, ot.created_at, ot.updated_at,
  c.name
FROM oauth2_token AS ot
LEFT JOIN datasource AS c ON c.oauth2_token_uuid = ot.uuid
WHERE 
  client_id = $1
`

type GetOauth2ClientTokensRow struct {
	UUID      uuid.UUID   `json:"uuid"`
	ClientID  string      `json:"client_id"`
	Token     []byte      `json:"token"`
	CreatedAt time.Time   `json:"created_at"`
	UpdatedAt time.Time   `json:"updated_at"`
	Name      pgtype.Text `json:"name"`
}

func (q *Queries) GetOauth2ClientTokens(ctx context.Context, clientID string) ([]GetOauth2ClientTokensRow, error) {
	rows, err := q.db.Query(ctx, getOauth2ClientTokens, clientID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetOauth2ClientTokensRow
	for rows.Next() {
		var i GetOauth2ClientTokensRow
		if err := rows.Scan(
			&i.UUID,
			&i.ClientID,
			&i.Token,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Name,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOauth2State = `-- name: GetOauth2State :one
SELECT
  uuid, client_name, client_id, state, created_at, updated_at, expired_at
FROM oauth2_state
WHERE 
  uuid = $1 AND expired_at > NOW()
LIMIT 1
`

func (q *Queries) GetOauth2State(ctx context.Context, argUuid uuid.UUID) (Oauth2State, error) {
	row := q.db.QueryRow(ctx, getOauth2State, argUuid)
	var i Oauth2State
	err := row.Scan(
		&i.UUID,
		&i.ClientName,
		&i.ClientID,
		&i.State,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ExpiredAt,
	)
	return i, err
}

const getOauth2TokenByUUID = `-- name: GetOauth2TokenByUUID :one
SELECT
  uuid, client_id, token, created_at, updated_at
FROM oauth2_token
WHERE "uuid" = $1
LIMIT 1
`

func (q *Queries) GetOauth2TokenByUUID(ctx context.Context, argUuid uuid.UUID) (Oauth2Token, error) {
	row := q.db.QueryRow(ctx, getOauth2TokenByUUID, argUuid)
	var i Oauth2Token
	err := row.Scan(
		&i.UUID,
		&i.ClientID,
		&i.Token,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getOauth2TokensByClientID = `-- name: GetOauth2TokensByClientID :many
SELECT
  uuid, client_id, token, created_at, updated_at
FROM oauth2_token
WHERE "client_id" = $1
`

func (q *Queries) GetOauth2TokensByClientID(ctx context.Context, id string) ([]Oauth2Token, error) {
	rows, err := q.db.Query(ctx, getOauth2TokensByClientID, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Oauth2Token
	for rows.Next() {
		var i Oauth2Token
		if err := rows.Scan(
			&i.UUID,
			&i.ClientID,
			&i.Token,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOauth2Clients = `-- name: ListOauth2Clients :many
SELECT
  id, name, provider, secret, created_at, updated_at
FROM oauth2_client
`

func (q *Queries) ListOauth2Clients(ctx context.Context) ([]Oauth2Client, error) {
	rows, err := q.db.Query(ctx, listOauth2Clients)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Oauth2Client
	for rows.Next() {
		var i Oauth2Client
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Provider,
			&i.Secret,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateOauth2Client = `-- name: UpdateOauth2Client :exec
UPDATE oauth2_client SET
  name = $1,
  provider = $2,
  secret = $3
WHERE id = $4
`

type UpdateOauth2ClientParams struct {
	Name     string `json:"name"`
	Provider string `json:"provider"`
	Secret   string `json:"secret"`
	ID       string `json:"id"`
}

func (q *Queries) UpdateOauth2Client(ctx context.Context, arg UpdateOauth2ClientParams) error {
	_, err := q.db.Exec(ctx, updateOauth2Client,
		arg.Name,
		arg.Provider,
		arg.Secret,
		arg.ID,
	)
	return err
}

const updateOauth2Token = `-- name: UpdateOauth2Token :exec
UPDATE oauth2_token SET
  token = $1
WHERE uuid = $2
`

type UpdateOauth2TokenParams struct {
	Token []byte    `json:"token"`
	UUID  uuid.UUID `json:"uuid"`
}

func (q *Queries) UpdateOauth2Token(ctx context.Context, arg UpdateOauth2TokenParams) error {
	_, err := q.db.Exec(ctx, updateOauth2Token, arg.Token, arg.UUID)
	return err
}
