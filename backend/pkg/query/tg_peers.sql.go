// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: tg_peers.sql

package query

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const tgFindPeer = `-- name: TgFindPeer :one
SELECT id, fk_session_id, peer_type, access_hash FROM tg_peers WHERE fk_session_id = $1 AND id = $2 AND peer_type = $3
`

type TgFindPeerParams struct {
	SessionID int64  `json:"session_id"`
	ID        int64  `json:"id"`
	PeerType  string `json:"peer_type"`
}

func (q *Queries) TgFindPeer(ctx context.Context, arg TgFindPeerParams) (TgPeer, error) {
	row := q.db.QueryRow(ctx, tgFindPeer, arg.SessionID, arg.ID, arg.PeerType)
	var i TgPeer
	err := row.Scan(
		&i.ID,
		&i.FkSessionID,
		&i.PeerType,
		&i.AccessHash,
	)
	return i, err
}

const tgFindPeerUserByPhone = `-- name: TgFindPeerUserByPhone :one
SELECT p.id, access_hash
FROM tg_peers_users pu
         JOIN tg_peers p ON p.id = tg_peers_users.id AND p.fk_session_id = tg_peers_users.fk_session_id
WHERE p.fk_session_id = $1 AND phone = $2
`

type TgFindPeerUserByPhoneParams struct {
	SessionID int64       `json:"session_id"`
	Phone     pgtype.Text `json:"phone"`
}

type TgFindPeerUserByPhoneRow struct {
	ID         int64       `json:"id"`
	AccessHash pgtype.Int8 `json:"access_hash"`
}

func (q *Queries) TgFindPeerUserByPhone(ctx context.Context, arg TgFindPeerUserByPhoneParams) (TgFindPeerUserByPhoneRow, error) {
	row := q.db.QueryRow(ctx, tgFindPeerUserByPhone, arg.SessionID, arg.Phone)
	var i TgFindPeerUserByPhoneRow
	err := row.Scan(&i.ID, &i.AccessHash)
	return i, err
}

const tgGetPeerChannel = `-- name: TgGetPeerChannel :one
SELECT id, fk_session_id, pts FROM tg_peers_channels WHERE fk_session_id = $1 AND id = $2
`

type TgGetPeerChannelParams struct {
	SessionID int64 `json:"session_id"`
	ID        int64 `json:"id"`
}

func (q *Queries) TgGetPeerChannel(ctx context.Context, arg TgGetPeerChannelParams) (TgPeersChannel, error) {
	row := q.db.QueryRow(ctx, tgGetPeerChannel, arg.SessionID, arg.ID)
	var i TgPeersChannel
	err := row.Scan(&i.ID, &i.FkSessionID, &i.Pts)
	return i, err
}

const tgGetPeersChannels = `-- name: TgGetPeersChannels :many
SELECT id, fk_session_id, pts FROM tg_peers_channels WHERE fk_session_id = $1
`

func (q *Queries) TgGetPeersChannels(ctx context.Context, sessionID int64) ([]TgPeersChannel, error) {
	rows, err := q.db.Query(ctx, tgGetPeersChannels, sessionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TgPeersChannel
	for rows.Next() {
		var i TgPeersChannel
		if err := rows.Scan(&i.ID, &i.FkSessionID, &i.Pts); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const tgSavePeer = `-- name: TgSavePeer :exec
INSERT INTO tg_peers (id, fk_session_id, peer_type, access_hash)
VALUES ($1, $2, $3, $4)
ON CONFLICT (id, fk_session_id)
    DO UPDATE SET peer_type = EXCLUDED.peer_type,
                  access_hash = COALESCE(EXCLUDED.access_hash, tg_peers.access_hash)
`

type TgSavePeerParams struct {
	ID         int64       `json:"id"`
	SessionID  int64       `json:"session_id"`
	PeerType   string      `json:"peer_type"`
	AccessHash pgtype.Int8 `json:"access_hash"`
}

func (q *Queries) TgSavePeer(ctx context.Context, arg TgSavePeerParams) error {
	_, err := q.db.Exec(ctx, tgSavePeer,
		arg.ID,
		arg.SessionID,
		arg.PeerType,
		arg.AccessHash,
	)
	return err
}

const tgSavePeerUserPhone = `-- name: TgSavePeerUserPhone :exec
INSERT INTO tg_peers_users (id, fk_session_id, phone)
VALUES ($1, $2, $3)
ON CONFLICT (id, fk_session_id)
    DO UPDATE SET phone = EXCLUDED.phone
`

type TgSavePeerUserPhoneParams struct {
	ID        int64       `json:"id"`
	SessionID int64       `json:"session_id"`
	Phone     pgtype.Text `json:"phone"`
}

func (q *Queries) TgSavePeerUserPhone(ctx context.Context, arg TgSavePeerUserPhoneParams) error {
	_, err := q.db.Exec(ctx, tgSavePeerUserPhone, arg.ID, arg.SessionID, arg.Phone)
	return err
}

const tgSetPeerChannelState = `-- name: TgSetPeerChannelState :exec
INSERT INTO tg_peers_channels (id, fk_session_id, pts)
VALUES ($1, $2, $3)
ON CONFLICT (id, fk_session_id)
    DO UPDATE SET pts = EXCLUDED.pts
`

type TgSetPeerChannelStateParams struct {
	ID        int64 `json:"id"`
	SessionID int64 `json:"session_id"`
	Pts       int64 `json:"pts"`
}

func (q *Queries) TgSetPeerChannelState(ctx context.Context, arg TgSetPeerChannelStateParams) error {
	_, err := q.db.Exec(ctx, tgSetPeerChannelState, arg.ID, arg.SessionID, arg.Pts)
	return err
}
