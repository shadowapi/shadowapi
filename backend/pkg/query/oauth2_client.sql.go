// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: oauth2_client.sql

package query

import (
	"context"

	"github.com/gofrs/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createOauth2Client = `-- name: CreateOauth2Client :one
INSERT INTO oauth2_client (
    uuid,
    name,
    provider,
    client_id,
    secret,
    created_at,
    updated_at
) VALUES (
             $1::uuid,
             $2,
             $3,
             $4,
             $5,
             NOW(),
             NOW()
         ) RETURNING uuid, name, provider, client_id, secret, created_at, updated_at
`

type CreateOauth2ClientParams struct {
	UUID     pgtype.UUID `json:"uuid"`
	Name     string      `json:"name"`
	Provider string      `json:"provider"`
	ClientID string      `json:"client_id"`
	Secret   string      `json:"secret"`
}

func (q *Queries) CreateOauth2Client(ctx context.Context, arg CreateOauth2ClientParams) (Oauth2Client, error) {
	row := q.db.QueryRow(ctx, createOauth2Client,
		arg.UUID,
		arg.Name,
		arg.Provider,
		arg.ClientID,
		arg.Secret,
	)
	var i Oauth2Client
	err := row.Scan(
		&i.UUID,
		&i.Name,
		&i.Provider,
		&i.ClientID,
		&i.Secret,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteOauth2Client = `-- name: DeleteOauth2Client :exec
DELETE FROM oauth2_client
WHERE uuid = $1::uuid
`

func (q *Queries) DeleteOauth2Client(ctx context.Context, argUuid pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteOauth2Client, argUuid)
	return err
}

const getOauth2Client = `-- name: GetOauth2Client :one
SELECT
    oauth2_client.uuid, oauth2_client.name, oauth2_client.provider, oauth2_client.client_id, oauth2_client.secret, oauth2_client.created_at, oauth2_client.updated_at
FROM oauth2_client
WHERE uuid = $1::uuid
`

type GetOauth2ClientRow struct {
	Oauth2Client Oauth2Client `json:"oauth2_client"`
}

func (q *Queries) GetOauth2Client(ctx context.Context, argUuid pgtype.UUID) (GetOauth2ClientRow, error) {
	row := q.db.QueryRow(ctx, getOauth2Client, argUuid)
	var i GetOauth2ClientRow
	err := row.Scan(
		&i.Oauth2Client.UUID,
		&i.Oauth2Client.Name,
		&i.Oauth2Client.Provider,
		&i.Oauth2Client.ClientID,
		&i.Oauth2Client.Secret,
		&i.Oauth2Client.CreatedAt,
		&i.Oauth2Client.UpdatedAt,
	)
	return i, err
}

const getOauth2Clients = `-- name: GetOauth2Clients :many
WITH filtered_oauth2_clients AS (
    SELECT oc.uuid, oc.name, oc.provider, oc.client_id, oc.secret, oc.created_at, oc.updated_at
    FROM oauth2_client oc
    WHERE
        (NULLIF($5, '') IS NULL OR oc.name = $5)
      AND (NULLIF($6, '') IS NULL OR oc.provider = $6)
)
SELECT
    uuid, name, provider, client_id, secret, created_at, updated_at,
    (SELECT count(*) FROM filtered_oauth2_clients) as total_count
FROM filtered_oauth2_clients
ORDER BY
    CASE WHEN $1 = 'created_at' AND $2 = 'asc' THEN created_at END ASC,
    CASE WHEN $1 = 'created_at' AND $2 = 'desc' THEN created_at END DESC,
    CASE WHEN $1 = 'updated_at' AND $2 = 'asc' THEN updated_at END ASC,
    CASE WHEN $1 = 'updated_at' AND $2 = 'desc' THEN updated_at END DESC,
    created_at DESC
LIMIT NULLIF($4::int, 0)
    OFFSET $3::int
`

type GetOauth2ClientsParams struct {
	OrderBy        interface{} `json:"order_by"`
	OrderDirection interface{} `json:"order_direction"`
	Offset         int32       `json:"offset"`
	Limit          int32       `json:"limit"`
	Name           interface{} `json:"name"`
	Provider       interface{} `json:"provider"`
}

type GetOauth2ClientsRow struct {
	UUID       uuid.UUID          `json:"uuid"`
	Name       string             `json:"name"`
	Provider   string             `json:"provider"`
	ClientID   string             `json:"client_id"`
	Secret     string             `json:"secret"`
	CreatedAt  pgtype.Timestamptz `json:"created_at"`
	UpdatedAt  pgtype.Timestamptz `json:"updated_at"`
	TotalCount int64              `json:"total_count"`
}

func (q *Queries) GetOauth2Clients(ctx context.Context, arg GetOauth2ClientsParams) ([]GetOauth2ClientsRow, error) {
	rows, err := q.db.Query(ctx, getOauth2Clients,
		arg.OrderBy,
		arg.OrderDirection,
		arg.Offset,
		arg.Limit,
		arg.Name,
		arg.Provider,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetOauth2ClientsRow
	for rows.Next() {
		var i GetOauth2ClientsRow
		if err := rows.Scan(
			&i.UUID,
			&i.Name,
			&i.Provider,
			&i.ClientID,
			&i.Secret,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOauth2Clients = `-- name: ListOauth2Clients :many
SELECT
    oauth2_client.uuid, oauth2_client.name, oauth2_client.provider, oauth2_client.client_id, oauth2_client.secret, oauth2_client.created_at, oauth2_client.updated_at
FROM oauth2_client
ORDER BY created_at DESC
LIMIT NULLIF($2::int, 0)
    OFFSET $1::int
`

type ListOauth2ClientsParams struct {
	Offset int32 `json:"offset"`
	Limit  int32 `json:"limit"`
}

type ListOauth2ClientsRow struct {
	Oauth2Client Oauth2Client `json:"oauth2_client"`
}

func (q *Queries) ListOauth2Clients(ctx context.Context, arg ListOauth2ClientsParams) ([]ListOauth2ClientsRow, error) {
	rows, err := q.db.Query(ctx, listOauth2Clients, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListOauth2ClientsRow
	for rows.Next() {
		var i ListOauth2ClientsRow
		if err := rows.Scan(
			&i.Oauth2Client.UUID,
			&i.Oauth2Client.Name,
			&i.Oauth2Client.Provider,
			&i.Oauth2Client.ClientID,
			&i.Oauth2Client.Secret,
			&i.Oauth2Client.CreatedAt,
			&i.Oauth2Client.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateOauth2Client = `-- name: UpdateOauth2Client :exec
UPDATE oauth2_client SET
                         name = $1,
                         provider = $2,
                         client_id = $3,
                         secret = $4,
                         updated_at = NOW()
WHERE uuid = $5::uuid
`

type UpdateOauth2ClientParams struct {
	Name     string      `json:"name"`
	Provider string      `json:"provider"`
	ClientID string      `json:"client_id"`
	Secret   string      `json:"secret"`
	UUID     pgtype.UUID `json:"uuid"`
}

func (q *Queries) UpdateOauth2Client(ctx context.Context, arg UpdateOauth2ClientParams) error {
	_, err := q.db.Exec(ctx, updateOauth2Client,
		arg.Name,
		arg.Provider,
		arg.ClientID,
		arg.Secret,
		arg.UUID,
	)
	return err
}
