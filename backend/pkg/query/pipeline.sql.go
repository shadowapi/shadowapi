// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: pipeline.sql

package query

import (
	"context"

	"github.com/gofrs/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const addPipelineEntry = `-- name: AddPipelineEntry :exec
INSERT INTO pipeline_entry (
  uuid, pipeline_uuid, parent_uuid, "type", params, created_at
) VALUES (
  $1, $2, $3, $4, $5, NOW()
) RETURNING uuid, pipeline_uuid, parent_uuid, type, params, created_at, updated_at
`

type AddPipelineEntryParams struct {
	UUID         uuid.UUID  `json:"uuid"`
	PipelineUuid *uuid.UUID `json:"pipeline_uuid"`
	ParentUuid   *uuid.UUID `json:"parent_uuid"`
	Type         string     `json:"type"`
	Params       []byte     `json:"params"`
}

func (q *Queries) AddPipelineEntry(ctx context.Context, arg AddPipelineEntryParams) error {
	_, err := q.db.Exec(ctx, addPipelineEntry,
		arg.UUID,
		arg.PipelineUuid,
		arg.ParentUuid,
		arg.Type,
		arg.Params,
	)
	return err
}

const createPipeline = `-- name: CreatePipeline :one
INSERT INTO pipeline (
  uuid, name, flow,
  created_at,
  updated_at
) VALUES (
  $1, $2, $3, NOW(), NOW()
) RETURNING uuid, name, flow, created_at, updated_at
`

type CreatePipelineParams struct {
	UUID uuid.UUID `json:"uuid"`
	Name string    `json:"name"`
	Flow []byte    `json:"flow"`
}

func (q *Queries) CreatePipeline(ctx context.Context, arg CreatePipelineParams) (Pipeline, error) {
	row := q.db.QueryRow(ctx, createPipeline, arg.UUID, arg.Name, arg.Flow)
	var i Pipeline
	err := row.Scan(
		&i.UUID,
		&i.Name,
		&i.Flow,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deletePipeline = `-- name: DeletePipeline :exec
DELETE FROM pipeline WHERE uuid = $1
`

func (q *Queries) DeletePipeline(ctx context.Context, argUuid uuid.UUID) error {
	_, err := q.db.Exec(ctx, deletePipeline, argUuid)
	return err
}

const deletePipelineEntry = `-- name: DeletePipelineEntry :exec
DELETE FROM pipeline_entry
WHERE uuid = $1
`

func (q *Queries) DeletePipelineEntry(ctx context.Context, argUuid uuid.UUID) error {
	_, err := q.db.Exec(ctx, deletePipelineEntry, argUuid)
	return err
}

const getPipelineEntries = `-- name: GetPipelineEntries :many
SELECT uuid, pipeline_uuid, parent_uuid, type, params, created_at, updated_at FROM pipeline_entry
WHERE
	($1 <> '' AND "pipeline_uuid" = $1) OR
	($2 <> '' AND "parent_uuid" = $2) OR
	($3 <> '' AND "type" = $3) OR
	($4 <> '' AND "name" like $4 )
ORDER BY created_at DESC
`

type GetPipelineEntriesParams struct {
	PipelineUuid interface{} `json:"pipeline_uuid"`
	ParentUuid   interface{} `json:"parent_uuid"`
	Type         interface{} `json:"type"`
	Name         interface{} `json:"name"`
}

func (q *Queries) GetPipelineEntries(ctx context.Context, arg GetPipelineEntriesParams) ([]PipelineEntry, error) {
	rows, err := q.db.Query(ctx, getPipelineEntries,
		arg.PipelineUuid,
		arg.ParentUuid,
		arg.Type,
		arg.Name,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PipelineEntry
	for rows.Next() {
		var i PipelineEntry
		if err := rows.Scan(
			&i.UUID,
			&i.PipelineUuid,
			&i.ParentUuid,
			&i.Type,
			&i.Params,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPipelineEntryByUUID = `-- name: GetPipelineEntryByUUID :one
SELECT uuid, pipeline_uuid, parent_uuid, type, params, created_at, updated_at FROM pipeline_entry
WHERE uuid = $1
`

func (q *Queries) GetPipelineEntryByUUID(ctx context.Context, argUuid uuid.UUID) (PipelineEntry, error) {
	row := q.db.QueryRow(ctx, getPipelineEntryByUUID, argUuid)
	var i PipelineEntry
	err := row.Scan(
		&i.UUID,
		&i.PipelineUuid,
		&i.ParentUuid,
		&i.Type,
		&i.Params,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getPipelines = `-- name: GetPipelines :many
SELECT
uuid, name, flow, created_at, updated_at
FROM pipeline
WHERE 
  -- if all params are null, select all
  ($1::text IS NULL
   AND $2::text IS NULL
   AND $3::timestamp IS NULL
  ) OR
  -- if any param is not null, filter
  ($1 IS NOT NULL AND "uuid"::text = $1::text)
  OR ($2 IS NOT NULL AND "name"::text like $2::text)
  OR ($3 IS NOT NULL AND "created_at" >= $3)
LIMIT $5 OFFSET $4
`

type GetPipelinesParams struct {
	UUID          pgtype.Text      `json:"uuid"`
	Name          pgtype.Text      `json:"name"`
	CreatedAtFrom pgtype.Timestamp `json:"created_at_from"`
	Offset        pgtype.Int4      `json:"offset"`
	Limit         pgtype.Int4      `json:"limit"`
}

func (q *Queries) GetPipelines(ctx context.Context, arg GetPipelinesParams) ([]Pipeline, error) {
	rows, err := q.db.Query(ctx, getPipelines,
		arg.UUID,
		arg.Name,
		arg.CreatedAtFrom,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Pipeline
	for rows.Next() {
		var i Pipeline
		if err := rows.Scan(
			&i.UUID,
			&i.Name,
			&i.Flow,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updatePipeline = `-- name: UpdatePipeline :exec
UPDATE pipeline SET
  name = COALESCE($1, name),
  flow = COALESCE($2, flow),
  updated_at = NOW()
WHERE uuid = $3
`

type UpdatePipelineParams struct {
	Name string    `json:"name"`
	Flow []byte    `json:"flow"`
	UUID uuid.UUID `json:"uuid"`
}

func (q *Queries) UpdatePipeline(ctx context.Context, arg UpdatePipelineParams) error {
	_, err := q.db.Exec(ctx, updatePipeline, arg.Name, arg.Flow, arg.UUID)
	return err
}

const updatePipelineEntry = `-- name: UpdatePipelineEntry :exec
UPDATE pipeline_entry SET
  params = COALESCE($1, params),
  updated_at = NOW()
WHERE uuid = $2
`

type UpdatePipelineEntryParams struct {
	Params []byte    `json:"params"`
	UUID   uuid.UUID `json:"uuid"`
}

func (q *Queries) UpdatePipelineEntry(ctx context.Context, arg UpdatePipelineEntryParams) error {
	_, err := q.db.Exec(ctx, updatePipelineEntry, arg.Params, arg.UUID)
	return err
}
