// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: pipeline.sql

package query

import (
	"context"

	"github.com/gofrs/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createPipeline = `-- name: CreatePipeline :one
INSERT INTO pipeline (
  uuid,
  datasource_uuid,
  name,
  type,
  is_enabled,
  flow,
  created_at,
  updated_at
) VALUES (
             $1::uuid,
             $2::uuid,
             NULLIF($3, ''),
             NULLIF($4, ''),
  $5::boolean,
              $6,
             NOW(),
  NOW()
) RETURNING uuid, datasource_uuid, name, type, is_enabled, flow, created_at, updated_at
`

type CreatePipelineParams struct {
	UUID           pgtype.UUID `json:"uuid"`
	DatasourceUUID pgtype.UUID `json:"datasource_uuid"`
	Name           interface{} `json:"name"`
	Type           interface{} `json:"type"`
	IsEnabled      bool        `json:"is_enabled"`
	Flow           []byte      `json:"flow"`
}

func (q *Queries) CreatePipeline(ctx context.Context, arg CreatePipelineParams) (Pipeline, error) {
	row := q.db.QueryRow(ctx, createPipeline,
		arg.UUID,
		arg.DatasourceUUID,
		arg.Name,
		arg.Type,
		arg.IsEnabled,
		arg.Flow,
	)
	var i Pipeline
	err := row.Scan(
		&i.UUID,
		&i.DatasourceUUID,
		&i.Name,
		&i.Type,
		&i.IsEnabled,
		&i.Flow,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deletePipeline = `-- name: DeletePipeline :exec
DELETE FROM pipeline WHERE uuid = $1::uuid
`

func (q *Queries) DeletePipeline(ctx context.Context, argUuid pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deletePipeline, argUuid)
	return err
}

const getPipeline = `-- name: GetPipeline :one
SELECT
    pipeline.uuid, pipeline.datasource_uuid, pipeline.name, pipeline.type, pipeline.is_enabled, pipeline.flow, pipeline.created_at, pipeline.updated_at
FROM pipeline
WHERE uuid = $1::uuid
`

type GetPipelineRow struct {
	Pipeline Pipeline `json:"pipeline"`
}

func (q *Queries) GetPipeline(ctx context.Context, argUuid pgtype.UUID) (GetPipelineRow, error) {
	row := q.db.QueryRow(ctx, getPipeline, argUuid)
	var i GetPipelineRow
	err := row.Scan(
		&i.Pipeline.UUID,
		&i.Pipeline.DatasourceUUID,
		&i.Pipeline.Name,
		&i.Pipeline.Type,
		&i.Pipeline.IsEnabled,
		&i.Pipeline.Flow,
		&i.Pipeline.CreatedAt,
		&i.Pipeline.UpdatedAt,
	)
	return i, err
}

const getPipelines = `-- name: GetPipelines :many
WITH filtered_pipelines AS (
    SELECT p.uuid, p.datasource_uuid, p.name, p.type, p.is_enabled, p.flow, p.created_at, p.updated_at
    FROM pipeline p
    WHERE
        (NULLIF($5, '') IS NULL OR p.uuid = $5::uuid)
      AND (NULLIF($6, '') IS NULL OR p.datasource_uuid = $6::uuid)
      AND (NULLIF($7, '') IS NULL OR p.type = $7)
      AND (NULLIF($8::int, -1) IS NULL OR p.is_enabled = $8::boolean)
      AND (NULLIF($9, '') IS NULL OR p.name ILIKE '%' || $9 || '%')
)
SELECT
    uuid, datasource_uuid, name, type, is_enabled, flow, created_at, updated_at,
    (SELECT count(*) FROM filtered_pipelines) AS total_count
FROM filtered_pipelines
ORDER BY
    CASE WHEN $1 = 'created_at' AND $2 = 'asc' THEN created_at END ASC,
    CASE WHEN $1 = 'created_at' AND $2 = 'desc' THEN created_at END DESC,
    CASE WHEN $1 = 'name' AND $2 = 'asc' THEN name END ASC,
    CASE WHEN $1 = 'name' AND $2 = 'desc' THEN name END DESC,
    CASE WHEN $1 = 'type' AND $2 = 'asc' THEN type END ASC,
    CASE WHEN $1 = 'type' AND $2 = 'desc' THEN type END DESC,
    created_at DESC
LIMIT NULLIF($4::int, 0)
    OFFSET $3::int
`

type GetPipelinesParams struct {
	OrderBy        interface{} `json:"order_by"`
	OrderDirection interface{} `json:"order_direction"`
	Offset         int32       `json:"offset"`
	Limit          int32       `json:"limit"`
	UUID           interface{} `json:"uuid"`
	DatasourceUUID interface{} `json:"datasource_uuid"`
	Type           interface{} `json:"type"`
	IsEnabled      int32       `json:"is_enabled"`
	Name           interface{} `json:"name"`
}

type GetPipelinesRow struct {
	UUID           uuid.UUID          `json:"uuid"`
	DatasourceUUID *uuid.UUID         `json:"datasource_uuid"`
	Name           string             `json:"name"`
	Type           string             `json:"type"`
	IsEnabled      bool               `json:"is_enabled"`
	Flow           []byte             `json:"flow"`
	CreatedAt      pgtype.Timestamptz `json:"created_at"`
	UpdatedAt      pgtype.Timestamptz `json:"updated_at"`
	TotalCount     int64              `json:"total_count"`
}

func (q *Queries) GetPipelines(ctx context.Context, arg GetPipelinesParams) ([]GetPipelinesRow, error) {
	rows, err := q.db.Query(ctx, getPipelines,
		arg.OrderBy,
		arg.OrderDirection,
		arg.Offset,
		arg.Limit,
		arg.UUID,
		arg.DatasourceUUID,
		arg.Type,
		arg.IsEnabled,
		arg.Name,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPipelinesRow
	for rows.Next() {
		var i GetPipelinesRow
		if err := rows.Scan(
			&i.UUID,
			&i.DatasourceUUID,
			&i.Name,
			&i.Type,
			&i.IsEnabled,
			&i.Flow,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPipelines = `-- name: ListPipelines :many
SELECT
    pipeline.uuid, pipeline.datasource_uuid, pipeline.name, pipeline.type, pipeline.is_enabled, pipeline.flow, pipeline.created_at, pipeline.updated_at
FROM pipeline
ORDER BY created_at DESC
LIMIT NULLIF($2::int, 0)
    OFFSET $1
`

type ListPipelinesParams struct {
	Offset int32 `json:"offset"`
	Limit  int32 `json:"limit"`
}

type ListPipelinesRow struct {
	Pipeline Pipeline `json:"pipeline"`
}

func (q *Queries) ListPipelines(ctx context.Context, arg ListPipelinesParams) ([]ListPipelinesRow, error) {
	rows, err := q.db.Query(ctx, listPipelines, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListPipelinesRow
	for rows.Next() {
		var i ListPipelinesRow
		if err := rows.Scan(
			&i.Pipeline.UUID,
			&i.Pipeline.DatasourceUUID,
			&i.Pipeline.Name,
			&i.Pipeline.Type,
			&i.Pipeline.IsEnabled,
			&i.Pipeline.Flow,
			&i.Pipeline.CreatedAt,
			&i.Pipeline.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updatePipeline = `-- name: UpdatePipeline :exec
UPDATE pipeline SET
  "name" = NULLIF($1, ''),
  "type" = NULLIF($2, ''),
  datasource_uuid = $3::uuid,
  is_enabled = $4::boolean,
  flow = $5,
  updated_at = NOW()
WHERE uuid = $6::uuid
`

type UpdatePipelineParams struct {
	Name           interface{} `json:"name"`
	Type           interface{} `json:"type"`
	DatasourceUUID pgtype.UUID `json:"datasource_uuid"`
	IsEnabled      bool        `json:"is_enabled"`
	Flow           []byte      `json:"flow"`
	UUID           pgtype.UUID `json:"uuid"`
}

func (q *Queries) UpdatePipeline(ctx context.Context, arg UpdatePipelineParams) error {
	_, err := q.db.Exec(ctx, updatePipeline,
		arg.Name,
		arg.Type,
		arg.DatasourceUUID,
		arg.IsEnabled,
		arg.Flow,
		arg.UUID,
	)
	return err
}
