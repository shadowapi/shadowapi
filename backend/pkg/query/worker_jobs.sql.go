// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: worker_jobs.sql

package query

import (
	"context"

	"github.com/gofrs/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createWorkerJob = `-- name: CreateWorkerJob :one
INSERT INTO worker_jobs (
    uuid,
    scheduler_uuid,
    subject,
    status,
    data,
    started_at,
    finished_at
) VALUES (
             $1::uuid,
             $2::uuid,
             $3,
             $4,
             $5,
             NOW(),
             $6
         )
RETURNING uuid, scheduler_uuid, subject, status, data, started_at, finished_at
`

type CreateWorkerJobParams struct {
	UUID          pgtype.UUID        `json:"uuid"`
	SchedulerUuid pgtype.UUID        `json:"scheduler_uuid"`
	Subject       string             `json:"subject"`
	Status        string             `json:"status"`
	Data          []byte             `json:"data"`
	FinishedAt    pgtype.Timestamptz `json:"finished_at"`
}

func (q *Queries) CreateWorkerJob(ctx context.Context, arg CreateWorkerJobParams) (WorkerJob, error) {
	row := q.db.QueryRow(ctx, createWorkerJob,
		arg.UUID,
		arg.SchedulerUuid,
		arg.Subject,
		arg.Status,
		arg.Data,
		arg.FinishedAt,
	)
	var i WorkerJob
	err := row.Scan(
		&i.UUID,
		&i.SchedulerUuid,
		&i.Subject,
		&i.Status,
		&i.Data,
		&i.StartedAt,
		&i.FinishedAt,
	)
	return i, err
}

const deleteWorkerJob = `-- name: DeleteWorkerJob :exec
DELETE FROM worker_jobs
WHERE uuid = $1::uuid
`

func (q *Queries) DeleteWorkerJob(ctx context.Context, argUuid pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteWorkerJob, argUuid)
	return err
}

const getWorkerJob = `-- name: GetWorkerJob :one
SELECT
    worker_jobs.uuid, worker_jobs.scheduler_uuid, worker_jobs.subject, worker_jobs.status, worker_jobs.data, worker_jobs.started_at, worker_jobs.finished_at
FROM worker_jobs
WHERE uuid = $1::uuid
`

type GetWorkerJobRow struct {
	WorkerJob WorkerJob `json:"worker_job"`
}

func (q *Queries) GetWorkerJob(ctx context.Context, argUuid pgtype.UUID) (GetWorkerJobRow, error) {
	row := q.db.QueryRow(ctx, getWorkerJob, argUuid)
	var i GetWorkerJobRow
	err := row.Scan(
		&i.WorkerJob.UUID,
		&i.WorkerJob.SchedulerUuid,
		&i.WorkerJob.Subject,
		&i.WorkerJob.Status,
		&i.WorkerJob.Data,
		&i.WorkerJob.StartedAt,
		&i.WorkerJob.FinishedAt,
	)
	return i, err
}

const getWorkerJobs = `-- name: GetWorkerJobs :many
WITH filtered_worker_jobs AS (
    SELECT w.uuid, w.scheduler_uuid, w.subject, w.status, w.data, w.started_at, w.finished_at
    FROM worker_jobs w
    WHERE
        ($5::uuid IS NULL
            OR w.scheduler_uuid = $5::uuid)
      AND (NULLIF($6, '') IS NULL
        OR w.subject = $6)
      AND (NULLIF($7, '') IS NULL
        OR w.status = $7)
)
SELECT
    uuid, scheduler_uuid, subject, status, data, started_at, finished_at,
    (SELECT COUNT(*) FROM filtered_worker_jobs) AS total_count
FROM filtered_worker_jobs
ORDER BY
    CASE WHEN $1 = 'started_at' AND $2 = 'asc'  THEN started_at END ASC,
    CASE WHEN $1 = 'started_at' AND $2 = 'desc' THEN started_at END DESC,

    CASE WHEN $1 = 'finished_at' AND $2 = 'asc'  THEN finished_at END ASC,
    CASE WHEN $1 = 'finished_at' AND $2 = 'desc' THEN finished_at END DESC,

    started_at DESC
LIMIT NULLIF($4::int, 0)
    OFFSET $3::int
`

type GetWorkerJobsParams struct {
	OrderBy        interface{} `json:"order_by"`
	OrderDirection interface{} `json:"order_direction"`
	Offset         int32       `json:"offset"`
	Limit          int32       `json:"limit"`
	SchedulerUuid  pgtype.UUID `json:"scheduler_uuid"`
	Subject        interface{} `json:"subject"`
	Status         interface{} `json:"status"`
}

type GetWorkerJobsRow struct {
	UUID          uuid.UUID          `json:"uuid"`
	SchedulerUuid *uuid.UUID         `json:"scheduler_uuid"`
	Subject       string             `json:"subject"`
	Status        string             `json:"status"`
	Data          []byte             `json:"data"`
	StartedAt     pgtype.Timestamptz `json:"started_at"`
	FinishedAt    pgtype.Timestamptz `json:"finished_at"`
	TotalCount    int64              `json:"total_count"`
}

func (q *Queries) GetWorkerJobs(ctx context.Context, arg GetWorkerJobsParams) ([]GetWorkerJobsRow, error) {
	rows, err := q.db.Query(ctx, getWorkerJobs,
		arg.OrderBy,
		arg.OrderDirection,
		arg.Offset,
		arg.Limit,
		arg.SchedulerUuid,
		arg.Subject,
		arg.Status,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetWorkerJobsRow
	for rows.Next() {
		var i GetWorkerJobsRow
		if err := rows.Scan(
			&i.UUID,
			&i.SchedulerUuid,
			&i.Subject,
			&i.Status,
			&i.Data,
			&i.StartedAt,
			&i.FinishedAt,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listWorkerJobs = `-- name: ListWorkerJobs :many
SELECT
    worker_jobs.uuid, worker_jobs.scheduler_uuid, worker_jobs.subject, worker_jobs.status, worker_jobs.data, worker_jobs.started_at, worker_jobs.finished_at
FROM worker_jobs
ORDER BY started_at DESC
LIMIT NULLIF($2::int, 0)
    OFFSET $1::int
`

type ListWorkerJobsParams struct {
	Offset int32 `json:"offset"`
	Limit  int32 `json:"limit"`
}

type ListWorkerJobsRow struct {
	WorkerJob WorkerJob `json:"worker_job"`
}

func (q *Queries) ListWorkerJobs(ctx context.Context, arg ListWorkerJobsParams) ([]ListWorkerJobsRow, error) {
	rows, err := q.db.Query(ctx, listWorkerJobs, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListWorkerJobsRow
	for rows.Next() {
		var i ListWorkerJobsRow
		if err := rows.Scan(
			&i.WorkerJob.UUID,
			&i.WorkerJob.SchedulerUuid,
			&i.WorkerJob.Subject,
			&i.WorkerJob.Status,
			&i.WorkerJob.Data,
			&i.WorkerJob.StartedAt,
			&i.WorkerJob.FinishedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateWorkerJob = `-- name: UpdateWorkerJob :exec
UPDATE worker_jobs
SET
    subject     = $1,
    status      = $2,
    data        = $3,
    finished_at = $4
WHERE uuid = $5::uuid
`

type UpdateWorkerJobParams struct {
	Subject    string             `json:"subject"`
	Status     string             `json:"status"`
	Data       []byte             `json:"data"`
	FinishedAt pgtype.Timestamptz `json:"finished_at"`
	UUID       pgtype.UUID        `json:"uuid"`
}

func (q *Queries) UpdateWorkerJob(ctx context.Context, arg UpdateWorkerJobParams) error {
	_, err := q.db.Exec(ctx, updateWorkerJob,
		arg.Subject,
		arg.Status,
		arg.Data,
		arg.FinishedAt,
		arg.UUID,
	)
	return err
}
