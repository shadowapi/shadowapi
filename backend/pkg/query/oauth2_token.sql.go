// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: oauth2_token.sql

package query

import (
	"context"

	"github.com/gofrs/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createOauth2Token = `-- name: CreateOauth2Token :one
INSERT INTO oauth2_token (
    uuid,
    client_uuid,
    user_uuid,
    access_token,
    refresh_token,
    expires_at,
    token,
    created_at,
    updated_at
) VALUES (
    $1::uuid,
    $2::uuid,
    $3::uuid,
    $4,
    $5,
    $6,
    $7,
    NOW(),
    NOW()
) RETURNING uuid, client_uuid, user_uuid, access_token, refresh_token, expires_at, token, created_at, updated_at, name
`

type CreateOauth2TokenParams struct {
	UUID         pgtype.UUID        `json:"uuid"`
	ClientUuid   pgtype.UUID        `json:"client_uuid"`
	UserUUID     pgtype.UUID        `json:"user_uuid"`
	AccessToken  string             `json:"access_token"`
	RefreshToken pgtype.Text        `json:"refresh_token"`
	ExpiresAt    pgtype.Timestamptz `json:"expires_at"`
	Token        []byte             `json:"token"`
}

func (q *Queries) CreateOauth2Token(ctx context.Context, arg CreateOauth2TokenParams) (Oauth2Token, error) {
	row := q.db.QueryRow(ctx, createOauth2Token,
		arg.UUID,
		arg.ClientUuid,
		arg.UserUUID,
		arg.AccessToken,
		arg.RefreshToken,
		arg.ExpiresAt,
		arg.Token,
	)
	var i Oauth2Token
	err := row.Scan(
		&i.UUID,
		&i.ClientUuid,
		&i.UserUUID,
		&i.AccessToken,
		&i.RefreshToken,
		&i.ExpiresAt,
		&i.Token,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Name,
	)
	return i, err
}

const deleteOauth2Token = `-- name: DeleteOauth2Token :exec
DELETE FROM oauth2_token
WHERE uuid = $1::uuid
`

func (q *Queries) DeleteOauth2Token(ctx context.Context, argUuid pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteOauth2Token, argUuid)
	return err
}

const deleteOauth2TokenByClientUUID = `-- name: DeleteOauth2TokenByClientUUID :exec
DELETE FROM oauth2_token
WHERE client_uuid = $1::uuid
`

func (q *Queries) DeleteOauth2TokenByClientUUID(ctx context.Context, clientUuid pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteOauth2TokenByClientUUID, clientUuid)
	return err
}

const getOauth2ClientTokens = `-- name: GetOauth2ClientTokens :many
SELECT
    ot.uuid, ot.client_uuid, ot.user_uuid, ot.access_token, ot.refresh_token, ot.expires_at, ot.token, ot.created_at, ot.updated_at, ot.name,
    c.name
FROM oauth2_token AS ot
         LEFT JOIN datasource AS c ON c.oauth2_token_uuid = ot.uuid
WHERE ot.client_uuid = $1::uuid
`

type GetOauth2ClientTokensRow struct {
	UUID         uuid.UUID          `json:"uuid"`
	ClientUuid   *uuid.UUID         `json:"client_uuid"`
	UserUUID     *uuid.UUID         `json:"user_uuid"`
	AccessToken  string             `json:"access_token"`
	RefreshToken pgtype.Text        `json:"refresh_token"`
	ExpiresAt    pgtype.Timestamptz `json:"expires_at"`
	Token        []byte             `json:"token"`
	CreatedAt    pgtype.Timestamptz `json:"created_at"`
	UpdatedAt    pgtype.Timestamptz `json:"updated_at"`
	Name         pgtype.Text        `json:"name"`
	Name_2       pgtype.Text        `json:"name_2"`
}

func (q *Queries) GetOauth2ClientTokens(ctx context.Context, clientUuid pgtype.UUID) ([]GetOauth2ClientTokensRow, error) {
	rows, err := q.db.Query(ctx, getOauth2ClientTokens, clientUuid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetOauth2ClientTokensRow
	for rows.Next() {
		var i GetOauth2ClientTokensRow
		if err := rows.Scan(
			&i.UUID,
			&i.ClientUuid,
			&i.UserUUID,
			&i.AccessToken,
			&i.RefreshToken,
			&i.ExpiresAt,
			&i.Token,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Name,
			&i.Name_2,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOauth2TokenByUUID = `-- name: GetOauth2TokenByUUID :one
SELECT
    oauth2_token.uuid, oauth2_token.client_uuid, oauth2_token.user_uuid, oauth2_token.access_token, oauth2_token.refresh_token, oauth2_token.expires_at, oauth2_token.token, oauth2_token.created_at, oauth2_token.updated_at, oauth2_token.name
FROM oauth2_token
WHERE client_uuid = $1::uuid
`

type GetOauth2TokenByUUIDRow struct {
	Oauth2Token Oauth2Token `json:"oauth2_token"`
}

func (q *Queries) GetOauth2TokenByUUID(ctx context.Context, argUuid pgtype.UUID) (GetOauth2TokenByUUIDRow, error) {
	row := q.db.QueryRow(ctx, getOauth2TokenByUUID, argUuid)
	var i GetOauth2TokenByUUIDRow
	err := row.Scan(
		&i.Oauth2Token.UUID,
		&i.Oauth2Token.ClientUuid,
		&i.Oauth2Token.UserUUID,
		&i.Oauth2Token.AccessToken,
		&i.Oauth2Token.RefreshToken,
		&i.Oauth2Token.ExpiresAt,
		&i.Oauth2Token.Token,
		&i.Oauth2Token.CreatedAt,
		&i.Oauth2Token.UpdatedAt,
		&i.Oauth2Token.Name,
	)
	return i, err
}

const getOauth2Tokens = `-- name: GetOauth2Tokens :many
WITH filtered_oauth2_tokens AS (
    SELECT ot.uuid, ot.client_uuid, ot.user_uuid, ot.access_token, ot.refresh_token, ot.expires_at, ot.token, ot.created_at, ot.updated_at, ot.name
    FROM oauth2_token ot
    WHERE
        (NULLIF($5, '') IS NULL OR ot.client_uuid = $5::uuid)
)
SELECT
    uuid, client_uuid, user_uuid, access_token, refresh_token, expires_at, token, created_at, updated_at, name,
    (SELECT count(*) FROM filtered_oauth2_tokens) as total_count
FROM filtered_oauth2_tokens
ORDER BY
    CASE WHEN $1 = 'created_at' AND $2 = 'asc' THEN created_at END ASC,
    CASE WHEN $1 = 'created_at' AND $2 = 'desc' THEN created_at END DESC,
    CASE WHEN $1 = 'updated_at' AND $2 = 'asc' THEN updated_at END ASC,
    CASE WHEN $1 = 'updated_at' AND $2 = 'desc' THEN updated_at END DESC,
    created_at DESC
LIMIT NULLIF($4::int, 0)
OFFSET $3::int
`

type GetOauth2TokensParams struct {
	OrderBy        interface{} `json:"order_by"`
	OrderDirection interface{} `json:"order_direction"`
	Offset         int32       `json:"offset"`
	Limit          int32       `json:"limit"`
	ClientUuid     interface{} `json:"client_uuid"`
}

type GetOauth2TokensRow struct {
	UUID         uuid.UUID          `json:"uuid"`
	ClientUuid   *uuid.UUID         `json:"client_uuid"`
	UserUUID     *uuid.UUID         `json:"user_uuid"`
	AccessToken  string             `json:"access_token"`
	RefreshToken pgtype.Text        `json:"refresh_token"`
	ExpiresAt    pgtype.Timestamptz `json:"expires_at"`
	Token        []byte             `json:"token"`
	CreatedAt    pgtype.Timestamptz `json:"created_at"`
	UpdatedAt    pgtype.Timestamptz `json:"updated_at"`
	Name         pgtype.Text        `json:"name"`
	TotalCount   int64              `json:"total_count"`
}

func (q *Queries) GetOauth2Tokens(ctx context.Context, arg GetOauth2TokensParams) ([]GetOauth2TokensRow, error) {
	rows, err := q.db.Query(ctx, getOauth2Tokens,
		arg.OrderBy,
		arg.OrderDirection,
		arg.Offset,
		arg.Limit,
		arg.ClientUuid,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetOauth2TokensRow
	for rows.Next() {
		var i GetOauth2TokensRow
		if err := rows.Scan(
			&i.UUID,
			&i.ClientUuid,
			&i.UserUUID,
			&i.AccessToken,
			&i.RefreshToken,
			&i.ExpiresAt,
			&i.Token,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Name,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOauth2TokensByClientUUID = `-- name: GetOauth2TokensByClientUUID :many
SELECT
    oauth2_token.uuid, oauth2_token.client_uuid, oauth2_token.user_uuid, oauth2_token.access_token, oauth2_token.refresh_token, oauth2_token.expires_at, oauth2_token.token, oauth2_token.created_at, oauth2_token.updated_at, oauth2_token.name
FROM oauth2_token
WHERE client_uuid = $1::uuid
`

type GetOauth2TokensByClientUUIDRow struct {
	Oauth2Token Oauth2Token `json:"oauth2_token"`
}

func (q *Queries) GetOauth2TokensByClientUUID(ctx context.Context, clientUuid pgtype.UUID) ([]GetOauth2TokensByClientUUIDRow, error) {
	rows, err := q.db.Query(ctx, getOauth2TokensByClientUUID, clientUuid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetOauth2TokensByClientUUIDRow
	for rows.Next() {
		var i GetOauth2TokensByClientUUIDRow
		if err := rows.Scan(
			&i.Oauth2Token.UUID,
			&i.Oauth2Token.ClientUuid,
			&i.Oauth2Token.UserUUID,
			&i.Oauth2Token.AccessToken,
			&i.Oauth2Token.RefreshToken,
			&i.Oauth2Token.ExpiresAt,
			&i.Oauth2Token.Token,
			&i.Oauth2Token.CreatedAt,
			&i.Oauth2Token.UpdatedAt,
			&i.Oauth2Token.Name,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTokensToRefresh = `-- name: GetTokensToRefresh :many
SELECT
    oauth2_token.uuid, oauth2_token.client_uuid, oauth2_token.user_uuid, oauth2_token.access_token, oauth2_token.refresh_token, oauth2_token.expires_at, oauth2_token.token, oauth2_token.created_at, oauth2_token.updated_at, oauth2_token.name
FROM oauth2_token
WHERE
   (NULLIF($1, '') IS NULL OR os.client_uuid = $1::uuid) AND
    expires_at < NOW() AND
    (updated_at IS NULL OR updated_at < NOW() - INTERVAL '1 hour')
`

type GetTokensToRefreshRow struct {
	Oauth2Token Oauth2Token `json:"oauth2_token"`
}

func (q *Queries) GetTokensToRefresh(ctx context.Context, clientUuid interface{}) ([]GetTokensToRefreshRow, error) {
	rows, err := q.db.Query(ctx, getTokensToRefresh, clientUuid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTokensToRefreshRow
	for rows.Next() {
		var i GetTokensToRefreshRow
		if err := rows.Scan(
			&i.Oauth2Token.UUID,
			&i.Oauth2Token.ClientUuid,
			&i.Oauth2Token.UserUUID,
			&i.Oauth2Token.AccessToken,
			&i.Oauth2Token.RefreshToken,
			&i.Oauth2Token.ExpiresAt,
			&i.Oauth2Token.Token,
			&i.Oauth2Token.CreatedAt,
			&i.Oauth2Token.UpdatedAt,
			&i.Oauth2Token.Name,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateOauth2Token = `-- name: UpdateOauth2Token :exec
UPDATE oauth2_token SET
                        client_uuid = $1::uuid,
    user_uuid = $2::uuid,
    access_token = $3,
    refresh_token = $4,
    expires_at = $5,
    token = $6,
    updated_at = NOW()
WHERE uuid = $7::uuid
`

type UpdateOauth2TokenParams struct {
	ClientUuid   pgtype.UUID        `json:"client_uuid"`
	UserUUID     pgtype.UUID        `json:"user_uuid"`
	AccessToken  string             `json:"access_token"`
	RefreshToken pgtype.Text        `json:"refresh_token"`
	ExpiresAt    pgtype.Timestamptz `json:"expires_at"`
	Token        []byte             `json:"token"`
	UUID         pgtype.UUID        `json:"uuid"`
}

func (q *Queries) UpdateOauth2Token(ctx context.Context, arg UpdateOauth2TokenParams) error {
	_, err := q.db.Exec(ctx, updateOauth2Token,
		arg.ClientUuid,
		arg.UserUUID,
		arg.AccessToken,
		arg.RefreshToken,
		arg.ExpiresAt,
		arg.Token,
		arg.UUID,
	)
	return err
}
