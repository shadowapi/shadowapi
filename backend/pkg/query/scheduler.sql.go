// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: scheduler.sql

package query

import (
	"context"

	"github.com/gofrs/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createScheduler = `-- name: CreateScheduler :one
INSERT INTO scheduler (
    uuid,
    pipeline_uuid,
    schedule_type,
    cron_expression,
    run_at,
    timezone,
    next_run,
    last_run,
    is_enabled,
    created_at,
    updated_at
) VALUES (
             $1::uuid,
             $2::uuid,
             $3,
             $4,
             $5,
             $6,
             $7,
             $8,
             $9::boolean,
             NOW(),
             NOW()
         ) RETURNING uuid, pipeline_uuid, schedule_type, cron_expression, run_at, timezone, next_run, last_run, is_enabled, created_at, updated_at
`

type CreateSchedulerParams struct {
	UUID           pgtype.UUID        `json:"uuid"`
	PipelineUuid   pgtype.UUID        `json:"pipeline_uuid"`
	ScheduleType   string             `json:"schedule_type"`
	CronExpression pgtype.Text        `json:"cron_expression"`
	RunAt          pgtype.Timestamptz `json:"run_at"`
	Timezone       string             `json:"timezone"`
	NextRun        pgtype.Timestamptz `json:"next_run"`
	LastRun        pgtype.Timestamptz `json:"last_run"`
	IsEnabled      bool               `json:"is_enabled"`
}

func (q *Queries) CreateScheduler(ctx context.Context, arg CreateSchedulerParams) (Scheduler, error) {
	row := q.db.QueryRow(ctx, createScheduler,
		arg.UUID,
		arg.PipelineUuid,
		arg.ScheduleType,
		arg.CronExpression,
		arg.RunAt,
		arg.Timezone,
		arg.NextRun,
		arg.LastRun,
		arg.IsEnabled,
	)
	var i Scheduler
	err := row.Scan(
		&i.UUID,
		&i.PipelineUuid,
		&i.ScheduleType,
		&i.CronExpression,
		&i.RunAt,
		&i.Timezone,
		&i.NextRun,
		&i.LastRun,
		&i.IsEnabled,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteScheduler = `-- name: DeleteScheduler :exec
DELETE FROM scheduler WHERE uuid = $1::uuid
`

func (q *Queries) DeleteScheduler(ctx context.Context, argUuid pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteScheduler, argUuid)
	return err
}

const getScheduler = `-- name: GetScheduler :one
SELECT
    scheduler.uuid, scheduler.pipeline_uuid, scheduler.schedule_type, scheduler.cron_expression, scheduler.run_at, scheduler.timezone, scheduler.next_run, scheduler.last_run, scheduler.is_enabled, scheduler.created_at, scheduler.updated_at
FROM scheduler
WHERE uuid = $1::uuid
`

type GetSchedulerRow struct {
	Scheduler Scheduler `json:"scheduler"`
}

func (q *Queries) GetScheduler(ctx context.Context, argUuid pgtype.UUID) (GetSchedulerRow, error) {
	row := q.db.QueryRow(ctx, getScheduler, argUuid)
	var i GetSchedulerRow
	err := row.Scan(
		&i.Scheduler.UUID,
		&i.Scheduler.PipelineUuid,
		&i.Scheduler.ScheduleType,
		&i.Scheduler.CronExpression,
		&i.Scheduler.RunAt,
		&i.Scheduler.Timezone,
		&i.Scheduler.NextRun,
		&i.Scheduler.LastRun,
		&i.Scheduler.IsEnabled,
		&i.Scheduler.CreatedAt,
		&i.Scheduler.UpdatedAt,
	)
	return i, err
}

const getSchedulers = `-- name: GetSchedulers :many
WITH filtered_schedulers AS (
    SELECT s.uuid, s.pipeline_uuid, s.schedule_type, s.cron_expression, s.run_at, s.timezone, s.next_run, s.last_run, s.is_enabled, s.created_at, s.updated_at
    FROM scheduler s
    WHERE
        (NULLIF($5, '') IS NULL OR s.schedule_type = $5) AND
        (NULLIF($6, '') IS NULL OR s.uuid = $6::uuid) AND
        (NULLIF($7, '') IS NULL OR s.pipeline_uuid = $7::uuid) AND
        (NULLIF($8::int, -1) IS NULL OR s.is_enabled = ($8::int)::boolean)
)
SELECT
    uuid, pipeline_uuid, schedule_type, cron_expression, run_at, timezone, next_run, last_run, is_enabled, created_at, updated_at,
    (SELECT count(*) FROM filtered_schedulers) as total_count
FROM filtered_schedulers
ORDER BY
    CASE WHEN $1 = 'created_at' AND $2 = 'asc' THEN created_at END ASC,
    CASE WHEN $1 = 'created_at' AND $2 = 'desc' THEN created_at END DESC,
    CASE WHEN $1 = 'updated_at' AND $2 = 'asc' THEN updated_at END ASC,
    CASE WHEN $1 = 'updated_at' AND $2 = 'desc' THEN updated_at END DESC,
    created_at DESC
LIMIT NULLIF($4::int, 0)
    OFFSET $3::int
`

type GetSchedulersParams struct {
	OrderBy        interface{} `json:"order_by"`
	OrderDirection interface{} `json:"order_direction"`
	Offset         int32       `json:"offset"`
	Limit          int32       `json:"limit"`
	ScheduleType   interface{} `json:"schedule_type"`
	UUID           interface{} `json:"uuid"`
	PipelineUuid   interface{} `json:"pipeline_uuid"`
	IsEnabled      int32       `json:"is_enabled"`
}

type GetSchedulersRow struct {
	UUID           uuid.UUID          `json:"uuid"`
	PipelineUuid   *uuid.UUID         `json:"pipeline_uuid"`
	ScheduleType   string             `json:"schedule_type"`
	CronExpression pgtype.Text        `json:"cron_expression"`
	RunAt          pgtype.Timestamptz `json:"run_at"`
	Timezone       string             `json:"timezone"`
	NextRun        pgtype.Timestamptz `json:"next_run"`
	LastRun        pgtype.Timestamptz `json:"last_run"`
	IsEnabled      bool               `json:"is_enabled"`
	CreatedAt      pgtype.Timestamptz `json:"created_at"`
	UpdatedAt      pgtype.Timestamptz `json:"updated_at"`
	TotalCount     int64              `json:"total_count"`
}

func (q *Queries) GetSchedulers(ctx context.Context, arg GetSchedulersParams) ([]GetSchedulersRow, error) {
	rows, err := q.db.Query(ctx, getSchedulers,
		arg.OrderBy,
		arg.OrderDirection,
		arg.Offset,
		arg.Limit,
		arg.ScheduleType,
		arg.UUID,
		arg.PipelineUuid,
		arg.IsEnabled,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSchedulersRow
	for rows.Next() {
		var i GetSchedulersRow
		if err := rows.Scan(
			&i.UUID,
			&i.PipelineUuid,
			&i.ScheduleType,
			&i.CronExpression,
			&i.RunAt,
			&i.Timezone,
			&i.NextRun,
			&i.LastRun,
			&i.IsEnabled,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSchedulers = `-- name: ListSchedulers :many
SELECT
    scheduler.uuid, scheduler.pipeline_uuid, scheduler.schedule_type, scheduler.cron_expression, scheduler.run_at, scheduler.timezone, scheduler.next_run, scheduler.last_run, scheduler.is_enabled, scheduler.created_at, scheduler.updated_at
FROM scheduler
ORDER BY created_at DESC
LIMIT NULLIF($2::int, 0)
    OFFSET $1
`

type ListSchedulersParams struct {
	Offset int32 `json:"offset"`
	Limit  int32 `json:"limit"`
}

type ListSchedulersRow struct {
	Scheduler Scheduler `json:"scheduler"`
}

func (q *Queries) ListSchedulers(ctx context.Context, arg ListSchedulersParams) ([]ListSchedulersRow, error) {
	rows, err := q.db.Query(ctx, listSchedulers, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListSchedulersRow
	for rows.Next() {
		var i ListSchedulersRow
		if err := rows.Scan(
			&i.Scheduler.UUID,
			&i.Scheduler.PipelineUuid,
			&i.Scheduler.ScheduleType,
			&i.Scheduler.CronExpression,
			&i.Scheduler.RunAt,
			&i.Scheduler.Timezone,
			&i.Scheduler.NextRun,
			&i.Scheduler.LastRun,
			&i.Scheduler.IsEnabled,
			&i.Scheduler.CreatedAt,
			&i.Scheduler.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateScheduler = `-- name: UpdateScheduler :exec
UPDATE scheduler SET
                     cron_expression = $1,
                     run_at = $2,
                     timezone = $3,
                     next_run = $4,
                     last_run = $5,
                     is_enabled = $6::boolean,
                     updated_at = NOW()
WHERE uuid = $7::uuid
`

type UpdateSchedulerParams struct {
	CronExpression pgtype.Text        `json:"cron_expression"`
	RunAt          pgtype.Timestamptz `json:"run_at"`
	Timezone       string             `json:"timezone"`
	NextRun        pgtype.Timestamptz `json:"next_run"`
	LastRun        pgtype.Timestamptz `json:"last_run"`
	IsEnabled      bool               `json:"is_enabled"`
	UUID           pgtype.UUID        `json:"uuid"`
}

func (q *Queries) UpdateScheduler(ctx context.Context, arg UpdateSchedulerParams) error {
	_, err := q.db.Exec(ctx, updateScheduler,
		arg.CronExpression,
		arg.RunAt,
		arg.Timezone,
		arg.NextRun,
		arg.LastRun,
		arg.IsEnabled,
		arg.UUID,
	)
	return err
}
